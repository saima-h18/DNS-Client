package lab1_416;


import java.io.*;
import java.net.*;
import java.util.Arrays;
import java.util.Random;
import java.util.Timer;
import java.lang.Math;
import java.lang.reflect.Array;

public class DnsClient {



	public static void main(String args[]) throws Exception
	{


		int timeout = 5;
		int maxRetry = 3;
		int port = 53;
		String Qtype = "A"; //1 = A , 2= NS, 15= MX

		String Qname = "";
		String ip = "";
		String auth = "";
		

		int indxArgs = 0;
		boolean at = false;
		boolean syntax = false;
	    boolean mx = false;
	    boolean ns = false;
	    boolean t = false;
	    boolean r = false;
	    boolean p = false;
		//reading the args


		try {

			for (int i = 0; i < args.length; i++) {
				
				if (args.length < 2) {
		            System.out.println("ERROR\tIncorrect input syntax: Server and name must be specified as inputs.");
		            
		        }
				
				char[] arrArgs = args[i].toCharArray();            
				for (int j = 0; j < arrArgs.length; j++) {  
					if(i==args.length-2) {
					if (arrArgs[j] == '@' ) {

						ip = args[i];
						Qname = args[i+1]; 
						at = true;
						break;
					}                   
//					else if (arrArgs[j] == '.') 
//						indxArgs++ ;

//					else if (arrArgs[j] != '@' && Character.isDigit(arrArgs[j]) && at)
//						//ipArr[indxArgs] += arrArgs[j];
//						ip = args[i];
//					//System.out.println("args" + args[i]);
//					}
					else {
						System.out.println("ERROR\t incorrect syntax");
					}
					
				}   
			}
			}

			
			for (int i = 0; i < args.length-2; i++) {
				syntax = false;

				char[] arrArgs = args[i].toCharArray();            
					for (int j = 0; j < arrArgs.length; j++) {  

					if (arrArgs[j] == '-'){
						if (arrArgs[j+1] == 't' && args[i].length()==2 && t==false) {
							i++;
							timeout = Integer.parseInt(args[i]);
							t = true;
							syntax = true;
						}
						else if (arrArgs[j+1] == 'r' && args[i].length()==2 && r==false) {
							i++;
							maxRetry = Integer.parseInt(args[i]);
							r = true;
							syntax = true;
						}
						else if (arrArgs[j+1] == 'p' && args[i].length()==2 && p==false) {
							i++;
							port = Integer.parseInt(args[i]);
							p = true;
							syntax = true;
						}
	
						else if (arrArgs[j+1] == 'm' && arrArgs[j+2] == 'x' && args[i].length()==3 && mx==false) {
							Qtype = "MX";
							mx = true;
							syntax = true;
						}
	
						else if (arrArgs[j+1] == 'n' && arrArgs[j+2] == 's' && args[i].length()==3 && ns==false) {
							Qtype = "NS";
							ns = true;
							syntax = true;
						}
						
					}
					if(syntax == false) {
						System.out.println(args[i]);
						System.out.println("ERROR\t Invalid Syntax");
						System.exit(1);
					}
					
					}
			}
			
	        if (mx && ns) {
	            System.out.println("ERROR\tIncorrect syntax: use only mx or ns.");
	        }
			
			if (!at) {                              
				System.out.println("The IP address entered is not correct. Please ensure to enter'@'");
				System.exit(1);
			}


			//            if (atSign >1) {
			//                System.out.println("ERROR   Only enter one '@'");
			//                System.exit(1);
			//            }

			if (timeout == 0){
				System.out.println("Please enter a value greater than 0 for the timeout");
				System.exit(1);
			}

		} 

		catch (IllegalArgumentException e) {
			System.out.println("Please make sure your arguments follows the correct format");
			System.exit(1);
		}
		if (ip == null || Qname == null) {
			System.out.println("Please make sure to provide the IP address and domain name");
			System.exit(1);
		}

		// Create a UDP socket
		// (Note, when no port number is specified, the OS will assign an arbitrary one)
		DatagramSocket clientSocket = new DatagramSocket();

		// Resolve a domain name to an IP address object
		// In this case, "localhost" maps to the so-called loop-back address, 127.0.0.1

		ip= ip.replaceAll("@","");
		String [] bytesString= ip.split("\\.");

		byte[] IPBytes = new byte [] {(byte) (Integer.parseInt(bytesString[0])), (byte) (Integer.parseInt(bytesString[1])), (byte) (Integer.parseInt(bytesString[2])), (byte) (Integer.parseInt(bytesString[3]))};



		InetAddress ipAddress = InetAddress.getByAddress(IPBytes);


		// Allocate buffers for the data to be sent and received
		byte[] sendData = new byte[1024];		
		byte[] receiveData = new byte[1024];



		Random y = new Random(); 
		byte[] two = new byte[2];
		y.nextBytes(two);

		// Header
		sendData[0] = two[0];
		sendData[1] = two[1];

		sendData[2] = 00000001;  //QR =0 , OPCODE = 0000 , AA =0 , TC=0 , RD =1 Recursion

		sendData[3] = 00000000; // Ra, Z, RCODE = 0

		sendData[4] = 00000000; // QDCOUNT = 1 , 16 bits

		sendData[5] = 00000001; // QDCOUNT = 1 , 16 bits

		sendData[6] = 00000000; // 

		sendData[7] = 00000000; // 

		sendData[8] = 00000000; // 

		sendData[9] = 00000000; // 

		sendData[10] = 0; // 
		sendData[11] = 0; // 

		//DATA


		int indx = 12;

		String [] Qstrings= Qname.split("\\.");

		int[] len = new int[Qstrings.length];

		for(int i=0; i< Qstrings.length ; i++) {
			sendData[indx++] = (byte) Qstrings[i].length();

			char[] carray = Qstrings[i].toCharArray();

			for(int j=0; j<carray.length; j++) {

				sendData[indx++] = (byte) carray[j]; //did operation then increment

			}

		}
		
		sendData[indx++] = 0; // End QName field 


		if(Qtype.equals("A")) {
			sendData[indx++] = 0;	
			sendData[indx++] = 1;	
		}
		else if (Qtype.equals("NS")) {
			sendData[indx++] = 0;	
			sendData[indx++] = 2;
		}

		else if (Qtype.equals("MX")) {
			sendData[indx++] = 0;	
			sendData[indx++] = 15;	
		}

		sendData[indx++] = 0;	
		sendData[indx++] = 1;	  // Qclass = 1



		// Create a UDP packet to be sent to the server
		// This involves specifying the sender's address and port number
		DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, port);


		// Send the packet
		clientSocket.send(sendPacket);
		long startTime = System.currentTimeMillis();

		// Summary of the query sent
		System.out.println("DnsClient sending request for " + "[" + Qname + "]" );
		System.out.println("Server:"+ "[" + ip + "]");
		System.out.println("Request type:" + "[" + Qtype + "]");


		// Create a packet structure to store data sent back by the server
		DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);

		int retry = 0;
		clientSocket.setSoTimeout(timeout*1000);

		while(retry<=maxRetry) {
			try {
				clientSocket.receive(receivePacket);
				break;
			}
			catch(SocketTimeoutException e) {
				clientSocket.send(sendPacket);
				retry++;
			}
		}


		if(retry>maxRetry) {
			try {
				maxRetriesError(maxRetry);
			}
			catch(SocketTimeoutException e){
				System.out.println("\n" + "ERROR" +"\t"+ "Maximum number of retries [" + maxRetry +"] exceeded");
			}
		}

		// Receive data from the server

		//clientSocket.receive(receivePacket);
		long endTime = System.currentTimeMillis();
		long timeTaken = (long)((endTime - startTime));
		System.out.println("Response received after " + timeTaken + " milliseconds " + "(["  + retry + "]) " + "retries");


		/////reading response//////

		byte[] byteRec = receivePacket.getData();
		parseResponse(byteRec,indx);

	}

    
		//Packet Header of the response

	static void parseResponse(byte[] receiveData1, int index) {

		// Checks if authoritative
		String auth1;
		if ((receiveData1[2] & 0x40) == 0x40) {
			auth1 = "auth";
		} else {
			auth1 = "noauth";
		}

		// Checks various header flags
		byte truncated, ra;
		truncated = (byte) (receiveData1[2] & 0x20);
		ra = (byte) (receiveData1[3] & 0x80);

		// If recursive queries are not supported, an error message is printed
		if (ra != (byte) 0x80)
			System.out.println("ERROR\tServer does not support recursive queries");

		// Checks the RCODE, printing various error messages if it is not 0 (no error condition)
		int RCODE = (receiveData1[3] & 0x0F);
		if (RCODE != 0x0) {
			if (RCODE == 0x1)
				System.out.println("ERROR\t[RCODE: 1] Format error");
			else if (RCODE == 0x2)
				System.out.println("ERROR\t[RCODE: 2] Server failure");
			else if (RCODE == 0x3)
				System.out.println("NOTFOUND\t[RCODE: 3] Referenced domain name does not exist");
			else if (RCODE == 0x4)
				System.out.println("ERROR\t[RCODE: 4] Not implemented");
			else // 0x5
				System.out.println("ERROR\t[RCODE: 5] Refused");
			System.exit(1);
		}

		// Gets the number of name server records in the Authority section
		int nsCount = (receiveData1[8] << 8) | receiveData1[9];

		// Gets the number of records in the Additional records section
		int arCount = (receiveData1[10] << 8) | receiveData1[11];

		// Gets the number of records in the Answer section
		int anCount = (receiveData1[6] << 8) | receiveData1[7];
		System.out.println("***Answer Section (" + anCount + " records)***");

		//Length is the length of the sent Header + Question
		int answerIndex = index + 1;

		// Parses the Answer Section
		answerIndex = parseSection(receiveData1, anCount, answerIndex, auth1, true);

		// Parses the Authority Section (in order to know the length of it)
		answerIndex = parseSection(receiveData1, nsCount, answerIndex, auth1, false);

		System.out.println("***Additional Section (" + arCount + " records)***");

		// Parses the Additional Section
		answerIndex = parseSection(receiveData1, arCount, answerIndex, auth1, true);
	}

	// Method used to parse a section of the packet, processing the various records contained
	public static int parseSection(byte[] receiveData, int count, int answerIndex, String auth, boolean print) {

		// Iterates through all the records in the section
		for (int i = 0; i < count; i++) {

			intString nameIndex = new intString();
			nameIndex.s = "";
			nameIndex.index = answerIndex;
			nameIndex = getName(receiveData, nameIndex.index);
			answerIndex = nameIndex.index;

			// Type
			int type = (receiveData[answerIndex] & 0xFF) << 8 | (receiveData[answerIndex + 1] & 0xFF);
			answerIndex += 2;

			// Class
			int clss = (receiveData[answerIndex] & 0xFF) << 8 | (receiveData[answerIndex + 1] & 0xFF);
			if (clss != 1){
				System.out.println("ERROR\tA record has an incorrect class value");
			}
			answerIndex += 2;

			// Time to live
			int ttl = ((receiveData[answerIndex] & 0xFF) << 24 | receiveData[answerIndex + 1] & 0xFF) << 16 | (receiveData[answerIndex + 2] & 0xFF) << 8 | (receiveData[answerIndex + 3] & 0xFF);
			answerIndex += 4;

			// Length of the RDATA field
			int rdLength = (receiveData[answerIndex] & 0xFF) << 8 | (receiveData[answerIndex + 1] & 0xFF);
			answerIndex += 2;

			// Gathers the data in the RDATA field
			byte[] rdData = new byte[rdLength];
			int rDataIndex = answerIndex;
			for (int j = 0; j < rdLength; j++) {
				rdData[j] = receiveData[answerIndex];
				answerIndex++;
			}
			if (print) {
				// Type A
				if (type == 1) {
					// RDATA is ip address for type A
					String ip_address = "";
					ip_address += Integer.toString(rdData[0] & 0xFF);
					for (int j = 1; j < rdLength; j++) {
						ip_address += ".";
						ip_address += Integer.toString((rdData[j] & 0xFF));
					}

					System.out.println("IP \t" + ip_address + "\t" + ttl + "\t" + auth);
				}

				// NS
				else if (type == 2) {
					// RDATA is server name for NS
					nameIndex = getName(receiveData, rDataIndex);
					String alias = nameIndex.s;
					System.out.println("NS \t" + alias + "\t" + ttl + "\t" + auth);
				}

				// CNAME
				else if (type == 5) {
					// RDATA is name of the alias for CNAME
					nameIndex = getName(receiveData, rDataIndex);
					String alias = nameIndex.s;
					System.out.println("CNAME \t" + alias + "\t" + ttl + "\t" + auth);
				}
				// MX
				else if (type == 15) {
					// RDATA is preference/exchange for MX
					int pref = (receiveData[rDataIndex] << 8) | receiveData[rDataIndex + 1];
					rDataIndex += 2;
					nameIndex = getName(receiveData, rDataIndex);
					String alias = nameIndex.s;
					System.out.println("MX \t" + alias + "\t" + pref + "\t" + ttl + "\t" + auth);
				}
			}
		}
		return answerIndex;
	}

	// Method used to parse domain names, it returns an index (used for the calculation of the length of the section) and the name
	static intString getName(byte[] receiveData, int answerIndex) {

		intString nameIndex = new intString();

		// Checks if it starts with a pointer
		if ((receiveData[answerIndex] & 0xFF) >= 0xC0) {
			nameIndex.s = getNameFromPointer(receiveData, answerIndex);
			answerIndex += 2;
			nameIndex.index = answerIndex;
			return nameIndex;
		}

		nameIndex.s = "";

		// Gets the name (or a portion of it)
		while (receiveData[answerIndex] != 0x00 && (receiveData[answerIndex] & 0xFF) < 0xc0) {
			int lengthWord = receiveData[answerIndex++];
			for (int i = 0; i < lengthWord; i++) {
				nameIndex.s += Character.toString((char) (receiveData[answerIndex++] & 0xFF));
			}
			nameIndex.s += ".";
		}

		// Checks if there is a pointer after the name
		if ((receiveData[answerIndex] & 0xFF) >= 0xc0) {
			nameIndex.s += getNameFromPointer(receiveData, answerIndex);
			answerIndex += 2;
			nameIndex.index = answerIndex;
			return nameIndex;
		}

		//remove the last "."
		nameIndex.s = nameIndex.s.substring(0, nameIndex.s.length() - 1);

		nameIndex.index = answerIndex;
		return nameIndex;
	}

	// Method used to get name data from a pointer
	static String getNameFromPointer(byte[] receiveData, int answerIndex) {

		// Gets the value of the pointer
		int offset = (receiveData[answerIndex] & 0xFF) << 8 | (receiveData[answerIndex + 1] & 0xFF);

		// Removes the leading "11" from the pointer
		offset -= 0xc000;

		// Gets the name the pointer points to
		String name = "";
		while (receiveData[offset] != 0x00) {
			int lengthWord = receiveData[offset++];
			for (int i = 0; i < lengthWord; i++) {
				name += Character.toString((char) (receiveData[offset++] & 0xFF));
			}
			name += ".";
		}

		// Remove the last "."
		name = name.substring(0, name.length() - 1);

		return name;


	}



	private static void maxRetriesError(int x) throws SocketTimeoutException {
		throw new SocketTimeoutException ();
	}


}
