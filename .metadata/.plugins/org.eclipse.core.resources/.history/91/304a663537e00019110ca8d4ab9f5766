package lab1_416;


import java.io.*;
import java.net.*;
import java.util.Arrays;
import java.util.Random;
import java.util.Timer;
import java.lang.Math;
import java.lang.reflect.Array;


public class DnsClient1 {

    public static void main(String[] args) throws SocketException, UnknownHostException {

        //default values for the various arguments
        int timeout = 5;
        int max_retries = 3;
        int port = 53;
        boolean a = true;
        boolean mx = false;
        boolean ns = false;
        boolean t = false;
        boolean r = false;
        boolean p = false;
        boolean validArg = false;
        String serverIP = "";

		//int timeout = 5;
		int maxRetry = 3;
		//int port = 53;
		String Qtype = "A"; //1 = A , 2= NS, 15= MX

		String Qname = "";
		String ip = "";
		String auth = "";
		

		int indxArgs = 0;
		boolean at = false;
		boolean syntax = false;
//	    boolean mx = false;
//	    boolean ns = false;
//	    boolean t = false;
//	    boolean r = false;
//	    boolean p = false;
		//reading the args


		try {

			for (int i = 0; i < args.length; i++) {
				
				if (args.length < 2) {
		            System.out.println("ERROR\tIncorrect input syntax: Server and name must be specified as inputs.");
		            
		        }
				
				char[] arrArgs = args[i].toCharArray();            
				for (int j = 0; j < arrArgs.length; j++) {  
					if(i==args.length-2) {
					if (arrArgs[j] == '@' ) {

						ip = args[i];
						Qname = args[i+1]; 
						at = true;
						break;
					}                   
//					else if (arrArgs[j] == '.') 
//						indxArgs++ ;

//					else if (arrArgs[j] != '@' && Character.isDigit(arrArgs[j]) && at)
//						//ipArr[indxArgs] += arrArgs[j];
//						ip = args[i];
//					//System.out.println("args" + args[i]);
//					}
					else {
						System.out.println("ERROR\t incorrect syntax");
					}
					
				}   
			}
			}

			
			for (int i = 0; i < args.length-2; i++) {
				syntax = false;

				char[] arrArgs = args[i].toCharArray();            
					for (int j = 0; j < arrArgs.length; j++) {  

					if (arrArgs[j] == '-'){
						if (arrArgs[j+1] == 't' && args[i].length()==2 && t==false) {
							i++;
							timeout = Integer.parseInt(args[i]);
							t = true;
							syntax = true;
						}
						else if (arrArgs[j+1] == 'r' && args[i].length()==2 && r==false) {
							i++;
							maxRetry = Integer.parseInt(args[i]);
							r = true;
							syntax = true;
						}
						else if (arrArgs[j+1] == 'p' && args[i].length()==2 && p==false) {
							i++;
							port = Integer.parseInt(args[i]);
							p = true;
							syntax = true;
						}
	
						else if (arrArgs[j+1] == 'm' && arrArgs[j+2] == 'x' && args[i].length()==3 && mx==false) {
							Qtype = "MX";
							mx = true;
							syntax = true;
						}
	
						else if (arrArgs[j+1] == 'n' && arrArgs[j+2] == 's' && args[i].length()==3 && ns==false) {
							Qtype = "NS";
							ns = true;
							syntax = true;
						}
						
					}
					if(syntax == false) {
						System.out.println(args[i]);
						System.out.println("ERROR\t Invalid Syntax");
						System.exit(1);
					}
					
					}
			}
			
	        if (mx && ns) {
	            System.out.println("ERROR\tIncorrect syntax: use only mx or ns.");
	        }
			
			if (!at) {                              
				System.out.println("The IP address entered is not correct. Please ensure to enter'@'");
				System.exit(1);
			}


			//            if (atSign >1) {
			//                System.out.println("ERROR   Only enter one '@'");
			//                System.exit(1);
			//            }

			if (timeout == 0){
				System.out.println("Please enter a value greater than 0 for the timeout");
				System.exit(1);
			}

		} 

		catch (IllegalArgumentException e) {
			System.out.println("Please make sure your arguments follows the correct format");
			System.exit(1);
		}
		if (ip == null || Qname == null) {
			System.out.println("Please make sure to provide the IP address and domain name");
			System.exit(1);
		}

	// Create a UDP socket
			// (Note, when no port number is specified, the OS will assign an arbitrary one)
			DatagramSocket clientSocket = new DatagramSocket();

			// Resolve a domain name to an IP address object
			// In this case, "localhost" maps to the so-called loop-back address, 127.0.0.1

			ip= ip.replaceAll("@","");
			String [] bytesString= ip.split("\\.");

			byte[] IPBytes = new byte [] {(byte) (Integer.parseInt(bytesString[0])), (byte) (Integer.parseInt(bytesString[1])), (byte) (Integer.parseInt(bytesString[2])), (byte) (Integer.parseInt(bytesString[3]))};

			InetAddress ipAddress = InetAddress.getByAddress(IPBytes);


        byte[] sendData = new byte[1024];
        byte[] receiveData = new byte[1024];

        Random rand = new Random();
        int randn = rand.nextInt(65536); 
        sendData[0] = (byte) randn;
        sendData[1] = (byte) (randn >> 8);
        sendData[2] = 0x01;           
        sendData[3] = 0;              
        sendData[4] = 0;
        sendData[5] = 0x01;           
        sendData[6] = 0;
        sendData[7] = 0;              
        sendData[8] = 0;
        sendData[9] = 0;              
        sendData[10] = 0;
        sendData[11] = 0;             


        
        String[] stringName = Qname.split("\\.");
        int length = 12;
        for (int i = 0; i < stringName.length; i++) {
            sendData[length] = (byte) stringName[i].length();
            length++;
            for (int j = 0; j < stringName[i].length(); j++) {
                sendData[length] = (byte) stringName[i].charAt(j);
                length++;
            }
        }
        sendData[length] = 0x00;
        length++;

        sendData[length] = 0x00;
        length++;
        if (a == true)
            sendData[length] = 0x01;
        else if (ns == true)
            sendData[length] = 0x02;
        else //mx == true
            sendData[length] = 0x0f;
        length++;

        sendData[length] = 0x00;
        length++;
        sendData[length] = 0x01;

        byte[] sendData2 = new byte[length+1];
        java.lang.System.arraycopy(sendData, 0, sendData2, 0, length+1);

        DatagramPacket sendPacket = new DatagramPacket(sendData2, sendData2.length, ipAddress, port);
        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);

        System.out.println("DnsClient sending request for " + Qname);
        System.out.println("Server: " + serverIP);
        if (a) {
            System.out.println("Request type: A");
        } else if (mx) {
            System.out.println("Request type: MX");
        } else if (ns) {
            System.out.println("Request type: NS");
        }

        long startTime = System.currentTimeMillis();

        int retry = 0;
		clientSocket.setSoTimeout(timeout*1000);


		if(retry>maxRetry) {
			try {
				maxRetriesError(maxRetry);
			}
			catch(SocketTimeoutException e){
				System.out.println("\n" + "ERROR" +"\t"+ "Maximum number of retries [" + maxRetry +"] exceeded");
			}
		}

		// Receive data from the server

		//clientSocket.receive(receivePacket);
		long endTime = System.currentTimeMillis();
		long timeTaken = (long)((endTime - startTime));
		System.out.println("Response received after " + timeTaken + " milliseconds " + "(["  + retry + "]) " + "retries");
    }

	static void parseResponse(byte[] receiveData1, int index) {

		String auth1;
		if ((receiveData1[2] & 0x40) == 0x40) {
			auth1 = "auth";
		} else {
			auth1 = "noauth";
		}

		byte truncated, ra;
		truncated = (byte) (receiveData1[2] & 0x20);
		ra = (byte) (receiveData1[3] & 0x80);

		if (ra != (byte) 0x80)
			System.out.println("ERROR\tServer does not support recursive queries");

		int RCODE = (receiveData1[3] & 0x0F);
		if (RCODE != 0x0) {
			if (RCODE == 0x1)
				System.out.println("ERROR\t[RCODE: 1] Format error");
			else if (RCODE == 0x2)
				System.out.println("ERROR\t[RCODE: 2] Server failure");
			else if (RCODE == 0x3)
				System.out.println("NOTFOUND\t[RCODE: 3] Referenced domain name does not exist");
			else if (RCODE == 0x4)
				System.out.println("ERROR\t[RCODE: 4] Not implemented");
			else // 0x5
				System.out.println("ERROR\t[RCODE: 5] Refused");
			System.exit(1);
		}

		int nsCount = (receiveData1[8] << 8) | receiveData1[9];

		int arCount = (receiveData1[10] << 8) | receiveData1[11];

		int anCount = (receiveData1[6] << 8) | receiveData1[7];
		System.out.println("***Answer Section (" + anCount + " records)***");

		int answerIndex = index + 1;

		answerIndex = parseSection(receiveData1, anCount, answerIndex, auth1, true);

		answerIndex = parseSection(receiveData1, nsCount, answerIndex, auth1, false);

		System.out.println("***Additional Section (" + arCount + " records)***");

		answerIndex = parseSection(receiveData1, arCount, answerIndex, auth1, true);
	}

	public static int parseSection(byte[] receiveData, int count, int answerIndex, String auth, boolean print) {

		for (int i = 0; i < count; i++) {

			intString nameIndex = new intString();
			nameIndex.s = "";
			nameIndex.index = answerIndex;
			nameIndex = getName(receiveData, nameIndex.index);
			answerIndex = nameIndex.index;

			int type = (receiveData[answerIndex] & 0xFF) << 8 | (receiveData[answerIndex + 1] & 0xFF);
			answerIndex += 2;

			int clss = (receiveData[answerIndex] & 0xFF) << 8 | (receiveData[answerIndex + 1] & 0xFF);
			if (clss != 1){
				System.out.println("ERROR\tA record has an incorrect class value");
			}
			answerIndex += 2;

			int ttl = ((receiveData[answerIndex] & 0xFF) << 24 | receiveData[answerIndex + 1] & 0xFF) << 16 | (receiveData[answerIndex + 2] & 0xFF) << 8 | (receiveData[answerIndex + 3] & 0xFF);
			answerIndex += 4;

			int rdLength = (receiveData[answerIndex] & 0xFF) << 8 | (receiveData[answerIndex + 1] & 0xFF);
			answerIndex += 2;

			byte[] rdData = new byte[rdLength];
			int rDataIndex = answerIndex;
			for (int j = 0; j < rdLength; j++) {
				rdData[j] = receiveData[answerIndex];
				answerIndex++;
			}
			if (print) {
				// Type A
				if (type == 1) {
					// RDATA is ip address for type A
					String ip_address = "";
					ip_address += Integer.toString(rdData[0] & 0xFF);
					for (int j = 1; j < rdLength; j++) {
						ip_address += ".";
						ip_address += Integer.toString((rdData[j] & 0xFF));
					}

					System.out.println("IP \t" + ip_address + "\t" + ttl + "\t" + auth);
				}

				else if (type == 2) {
					nameIndex = getName(receiveData, rDataIndex);
					String alias = nameIndex.s;
					System.out.println("NS \t" + alias + "\t" + ttl + "\t" + auth);
				}

				else if (type == 5) {
					nameIndex = getName(receiveData, rDataIndex);
					String alias = nameIndex.s;
					System.out.println("CNAME \t" + alias + "\t" + ttl + "\t" + auth);
				}
				else if (type == 15) {
					int pref = (receiveData[rDataIndex] << 8) | receiveData[rDataIndex + 1];
					rDataIndex += 2;
					nameIndex = getName(receiveData, rDataIndex);
					String alias = nameIndex.s;
					System.out.println("MX \t" + alias + "\t" + pref + "\t" + ttl + "\t" + auth);
				}
			}
		}
		return answerIndex;
	}

	static intString getName(byte[] receiveData, int answerIndex) {

		intString nameIndex = new intString();

		if ((receiveData[answerIndex] & 0xFF) >= 0xC0) {
			nameIndex.s = getNameFromPointer(receiveData, answerIndex);
			answerIndex += 2;
			nameIndex.index = answerIndex;
			return nameIndex;
		}

		nameIndex.s = "";

		while (receiveData[answerIndex] != 0x00 && (receiveData[answerIndex] & 0xFF) < 0xc0) {
			int lengthWord = receiveData[answerIndex++];
			for (int i = 0; i < lengthWord; i++) {
				nameIndex.s += Character.toString((char) (receiveData[answerIndex++] & 0xFF));
			}
			nameIndex.s += ".";
		}

		if ((receiveData[answerIndex] & 0xFF) >= 0xc0) {
			nameIndex.s += getNameFromPointer(receiveData, answerIndex);
			answerIndex += 2;
			nameIndex.index = answerIndex;
			return nameIndex;
		}

		nameIndex.s = nameIndex.s.substring(0, nameIndex.s.length() - 1);

		nameIndex.index = answerIndex;
		return nameIndex;
	}

	static String getNameFromPointer(byte[] receiveData, int answerIndex) {

		int offset = (receiveData[answerIndex] & 0xFF) << 8 | (receiveData[answerIndex + 1] & 0xFF);

		offset -= 0xc000;

		String name = "";
		while (receiveData[offset] != 0x00) {
			int lengthWord = receiveData[offset++];
			for (int i = 0; i < lengthWord; i++) {
				name += Character.toString((char) (receiveData[offset++] & 0xFF));
			}
			name += ".";
		}

		name = name.substring(0, name.length() - 1);

		return name;


	}



	private static void maxRetriesError(int x) throws SocketTimeoutException {
		throw new SocketTimeoutException ();
	}


}
